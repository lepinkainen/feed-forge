package feed

import (
	"fmt"
	"log/slog"
	"strings"
	"time"

	"github.com/lepinkainen/feed-forge/pkg/opengraph"
	"github.com/lepinkainen/feed-forge/pkg/providers"
)

// EnhancedAtomConfig configures enhanced Atom feed generation
type EnhancedAtomConfig struct {
	// Custom namespace information
	CustomNamespace    string
	CustomNamespaceURI string

	// Feed metadata
	Title        string
	Link         string
	ID           string
	Subtitle     string
	Author       string
	Generator    string
	GeneratorURI string

	// Entry customization
	MultipleLinks       bool // Support for multiple link types per entry
	EnhancedContent     bool // Rich HTML content with OpenGraph
	CustomMetadata      bool // Provider-specific metadata in custom namespace
	Enclosures          bool // Support for media enclosures
	ExtendedAuthor      bool // Author with URI information
	CommentsLinkDefault bool // Use comments link as the default link instead of article link

	// Content enhancement
	OpenGraphIntegration bool
}

// DefaultEnhancedAtomConfig returns a default configuration for enhanced Atom feeds
func DefaultEnhancedAtomConfig() *EnhancedAtomConfig {
	return &EnhancedAtomConfig{
		Title:                "Enhanced Feed",
		Link:                 "https://example.com",
		ID:                   "https://example.com",
		Subtitle:             "Generated by Feed Forge",
		Author:               "Feed Forge",
		Generator:            "Feed Forge",
		GeneratorURI:         "https://github.com/lepinkainen/feed-forge",
		MultipleLinks:        true,
		EnhancedContent:      true,
		CustomMetadata:       false,
		Enclosures:           true,
		ExtendedAuthor:       true,
		CommentsLinkDefault:  false, // Default behavior: article link is primary
		OpenGraphIntegration: true,
	}
}

// RedditEnhancedAtomConfig returns a configuration optimized for Reddit feeds
func RedditEnhancedAtomConfig() *EnhancedAtomConfig {
	config := DefaultEnhancedAtomConfig()
	config.CustomNamespace = "reddit"
	config.CustomNamespaceURI = "http://reddit.com/atom/ns"
	config.Title = "Reddit Homepage"
	config.Link = "https://www.reddit.com/"
	config.ID = "https://www.reddit.com/"
	config.Subtitle = "Filtered Reddit homepage posts with enhanced metadata"
	config.Generator = "Red RSS Generator"
	config.CustomMetadata = true
	config.CommentsLinkDefault = true // For Reddit, default link should be comments
	return config
}

// HackerNewsEnhancedAtomConfig returns a configuration optimized for Hacker News feeds
func HackerNewsEnhancedAtomConfig() *EnhancedAtomConfig {
	config := DefaultEnhancedAtomConfig()
	config.CustomNamespace = "hn"
	config.CustomNamespaceURI = "http://news.ycombinator.com/atom/ns"
	config.Title = "Hacker News Top Stories"
	config.Link = "https://news.ycombinator.com/"
	config.ID = "https://news.ycombinator.com/"
	config.Subtitle = "High-quality Hacker News stories, updated regularly"
	config.CustomMetadata = true
	config.CommentsLinkDefault = true // For HN, default link should be comments
	return config
}

// GenerateEnhancedAtomWithConfig creates an enhanced Atom feed using the provided configuration
func (g *Generator) GenerateEnhancedAtomWithConfig(
	items []providers.FeedItem,
	config *EnhancedAtomConfig,
	ogFetcher *opengraph.Fetcher,
) (string, error) {
	now := time.Now()

	// Collect URLs for OpenGraph fetching if enabled
	var ogDataMap map[string]*opengraph.Data
	if config.OpenGraphIntegration && ogFetcher != nil {
		urls := make([]string, 0, len(items))
		for _, item := range items {
			if item.Link() != "" {
				urls = append(urls, item.Link())
			}
		}

		if len(urls) > 0 {
			slog.Debug("Fetching OpenGraph data for enhanced Atom feed", "urlCount", len(urls))
			ogDataMap = ogFetcher.FetchConcurrent(urls)
		}
	}

	var atom strings.Builder
	atom.WriteString(`<?xml version="1.0" encoding="UTF-8"?>`)

	// Build feed opening tag - always use standard namespaces only
	atom.WriteString(`<feed xmlns="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/">`)

	// Feed metadata
	atom.WriteString(fmt.Sprintf(`<title>%s</title>`, EscapeXML(config.Title)))
	atom.WriteString(fmt.Sprintf(`<link href="%s"/>`, EscapeXML(config.Link)))
	atom.WriteString(fmt.Sprintf(`<id>%s</id>`, EscapeXML(config.ID)))
	atom.WriteString(fmt.Sprintf(`<updated>%s</updated>`, now.Format(time.RFC3339)))
	atom.WriteString(fmt.Sprintf(`<author><name>%s</name></author>`, EscapeXML(config.Author)))
	atom.WriteString(fmt.Sprintf(`<subtitle>%s</subtitle>`, EscapeXML(config.Subtitle)))

	if config.Generator != "" {
		if config.GeneratorURI != "" {
			atom.WriteString(fmt.Sprintf(`<generator uri="%s">%s</generator>`,
				EscapeXML(config.GeneratorURI), EscapeXML(config.Generator)))
		} else {
			atom.WriteString(fmt.Sprintf(`<generator>%s</generator>`, EscapeXML(config.Generator)))
		}
	}

	// Generate entries
	for _, item := range items {
		atom.WriteString(`<entry>`)
		atom.WriteString(fmt.Sprintf(`<title>%s</title>`, EscapeXML(item.Title())))

		// Handle multiple links if enabled
		if config.MultipleLinks {
			g.generateMultipleLinks(&atom, item, config.CommentsLinkDefault)
		} else {
			// For single link mode, respect CommentsLinkDefault setting
			if config.CommentsLinkDefault && item.CommentsLink() != "" {
				atom.WriteString(fmt.Sprintf(`<link rel="alternate" type="text/html" href="%s"/>`, EscapeXML(item.CommentsLink())))
			} else {
				atom.WriteString(fmt.Sprintf(`<link rel="alternate" type="text/html" href="%s"/>`, EscapeXML(item.Link())))
			}
		}

		atom.WriteString(fmt.Sprintf(`<id>%s</id>`, EscapeXML(item.CommentsLink())))
		atom.WriteString(fmt.Sprintf(`<updated>%s</updated>`, item.CreatedAt().Format(time.RFC3339)))
		atom.WriteString(fmt.Sprintf(`<published>%s</published>`, item.CreatedAt().Format(time.RFC3339)))

		// Enhanced author information
		if config.ExtendedAuthor {
			g.generateExtendedAuthor(&atom, item)
		} else {
			atom.WriteString(fmt.Sprintf(`<author><name>%s</name></author>`, EscapeXML(item.Author())))
		}

		// Categories
		for _, category := range item.Categories() {
			atom.WriteString(fmt.Sprintf(`<category term="%s" label="%s"/>`, EscapeXML(category), EscapeXML(category)))
		}

		// Custom metadata if enabled
		if config.CustomMetadata && config.CustomNamespace != "" {
			g.generateCustomMetadata(&atom, item, config.CustomNamespace)
		}

		// Enhanced content
		if config.EnhancedContent {
			content := g.buildProviderEnhancedContent(item, ogDataMap)
			atom.WriteString(fmt.Sprintf(`<content type="html"><![CDATA[%s]]></content>`, content))
		} else {
			description := fmt.Sprintf("Score: %d | Comments: %d", item.Score(), item.CommentCount())
			atom.WriteString(fmt.Sprintf(`<content type="html"><![CDATA[%s]]></content>`, description))
		}

		// Summary
		summary := fmt.Sprintf("Score: %d | Comments: %d", item.Score(), item.CommentCount())
		atom.WriteString(fmt.Sprintf(`<summary>%s</summary>`, EscapeXML(summary)))

		// Enclosures if enabled
		if config.Enclosures && ogDataMap != nil {
			g.generateEnclosures(&atom, item, ogDataMap)
		}

		// Media thumbnails for Reddit posts with images
		g.generateMediaThumbnail(&atom, item)

		atom.WriteString(`</entry>`)
	}

	atom.WriteString(`</feed>`)
	return atom.String(), nil
}

// generateMultipleLinks handles multiple link types for an entry
func (g *Generator) generateMultipleLinks(atom *strings.Builder, item providers.FeedItem, commentsLinkDefault bool) {
	if commentsLinkDefault {
		// For platforms like HN, prioritize comments link as main link
		if item.CommentsLink() != "" {
			atom.WriteString(fmt.Sprintf(`<link rel="alternate" type="text/html" href="%s"/>`, EscapeXML(item.CommentsLink())))
		}

		// Article link as secondary
		if item.Link() != "" && item.Link() != item.CommentsLink() {
			atom.WriteString(fmt.Sprintf(`<link rel="related" type="text/html" href="%s" title="Article"/>`, EscapeXML(item.Link())))
		}
	} else {
		// Default behavior: article link as main link
		if item.Link() != "" {
			atom.WriteString(fmt.Sprintf(`<link rel="alternate" type="text/html" href="%s"/>`, EscapeXML(item.Link())))
		}

		// Comments link as secondary
		if item.CommentsLink() != "" && item.CommentsLink() != item.Link() {
			atom.WriteString(fmt.Sprintf(`<link rel="replies" type="text/html" href="%s" title="Comments"/>`, EscapeXML(item.CommentsLink())))
		}
	}
}

// generateExtendedAuthor creates enhanced author information with URI
func (g *Generator) generateExtendedAuthor(atom *strings.Builder, item providers.FeedItem) {
	author := item.Author()
	if author == "" {
		return
	}

	// Try to generate author URI based on the source
	authorURI := g.generateAuthorURI(item, author)
	if authorURI != "" {
		atom.WriteString(fmt.Sprintf(`<author><name>%s</name><uri>%s</uri></author>`,
			EscapeXML(author), EscapeXML(authorURI)))
	} else {
		atom.WriteString(fmt.Sprintf(`<author><name>%s</name></author>`, EscapeXML(author)))
	}
}

// generateAuthorURI creates author URI based on the platform
func (g *Generator) generateAuthorURI(item providers.FeedItem, author string) string {
	commentsLink := item.CommentsLink()

	// Reddit detection
	if strings.Contains(commentsLink, "reddit.com") {
		return fmt.Sprintf("https://www.reddit.com/user/%s", author)
	}

	// Hacker News detection
	if strings.Contains(commentsLink, "news.ycombinator.com") {
		return fmt.Sprintf("https://news.ycombinator.com/user?id=%s", author)
	}

	return ""
}

// generateCustomMetadata adds provider-specific metadata in custom namespace
func (g *Generator) generateCustomMetadata(atom *strings.Builder, item providers.FeedItem, namespace string) {
	switch namespace {
	case "reddit":
		g.generateRedditMetadata(atom, item)
	case "hn":
		g.generateHackerNewsMetadata(atom, item)
	}
}

// generateRedditMetadata adds Reddit-specific metadata as standard categories
func (g *Generator) generateRedditMetadata(atom *strings.Builder, item providers.FeedItem) {
	atom.WriteString(fmt.Sprintf(`<category term="score:%d" label="Score: %d" scheme="reddit-metadata"/>`, item.Score(), item.Score()))
	atom.WriteString(fmt.Sprintf(`<category term="comments:%d" label="Comments: %d" scheme="reddit-metadata"/>`, item.CommentCount(), item.CommentCount()))

	// Extract subreddit from categories if available
	for _, category := range item.Categories() {
		if strings.HasPrefix(category, "r/") {
			subreddit := strings.TrimPrefix(category, "r/")
			atom.WriteString(fmt.Sprintf(`<category term="subreddit:%s" label="Subreddit: r/%s" scheme="reddit-metadata"/>`, EscapeXML(subreddit), EscapeXML(subreddit)))
			break
		}
	}
}

// generateHackerNewsMetadata adds Hacker News-specific metadata as standard categories
func (g *Generator) generateHackerNewsMetadata(atom *strings.Builder, item providers.FeedItem) {
	atom.WriteString(fmt.Sprintf(`<category term="points:%d" label="Points: %d" scheme="hackernews-metadata"/>`, item.Score(), item.Score()))
	atom.WriteString(fmt.Sprintf(`<category term="comments:%d" label="Comments: %d" scheme="hackernews-metadata"/>`, item.CommentCount(), item.CommentCount()))

	// Add domain if available from categories
	for _, category := range item.Categories() {
		if !strings.Contains(category, " ") && strings.Contains(category, ".") {
			atom.WriteString(fmt.Sprintf(`<category term="domain:%s" label="Domain: %s" scheme="hackernews-metadata"/>`, EscapeXML(category), EscapeXML(category)))
			break
		}
	}
}

// generateEnclosures adds media enclosures from OpenGraph data
func (g *Generator) generateEnclosures(atom *strings.Builder, item providers.FeedItem, ogDataMap map[string]*opengraph.Data) {
	if ogDataMap == nil || item.Link() == "" {
		return
	}

	if og, exists := ogDataMap[item.Link()]; exists && og != nil && og.Image != "" {
		atom.WriteString(fmt.Sprintf(`<link rel="enclosure" type="image/jpeg" href="%s"/>`, EscapeXML(og.Image)))
	}
}

// buildProviderEnhancedContent creates rich HTML content with OpenGraph integration
func (g *Generator) buildProviderEnhancedContent(item providers.FeedItem, ogDataMap map[string]*opengraph.Data) string {
	var content strings.Builder

	// Base metadata
	content.WriteString(fmt.Sprintf(`<div class="metadata">
<p><strong>Score:</strong> %d | <strong>Comments:</strong> %d</p>
</div>`, item.Score(), item.CommentCount()))

	// OpenGraph preview if available
	if ogDataMap != nil && item.Link() != "" {
		if og, exists := ogDataMap[item.Link()]; exists && og != nil {
			content.WriteString(`<div class="link-preview">`)
			content.WriteString(`<h3>ðŸ”— Link Preview</h3>`)

			if og.Image != "" {
				content.WriteString(fmt.Sprintf(`<img src="%s" alt="Preview image" style="max-width: 200px; height: auto;"/>`, og.Image))
			}

			if og.Title != "" {
				content.WriteString(fmt.Sprintf(`<h4>%s</h4>`, og.Title))
			}

			if og.Description != "" {
				content.WriteString(fmt.Sprintf(`<p>%s</p>`, og.Description))
			}

			if og.SiteName != "" {
				content.WriteString(fmt.Sprintf(`<p><em>Source: %s</em></p>`, og.SiteName))
			}

			content.WriteString(`</div>`)
		}
	}

	// Links section
	content.WriteString(`<div class="links">`)
	if item.Link() != "" && item.CommentsLink() != "" && item.Link() != item.CommentsLink() {
		content.WriteString(fmt.Sprintf(`<p><a href="%s">View External Link</a> | <a href="%s">View Comments</a></p>`, item.Link(), item.CommentsLink()))
	} else if item.Link() != "" {
		content.WriteString(fmt.Sprintf(`<p><a href="%s">View Link</a></p>`, item.Link()))
	}
	content.WriteString(`</div>`)

	return content.String()
}

// generateMediaThumbnail adds media:thumbnail element for posts with images
func (g *Generator) generateMediaThumbnail(atom *strings.Builder, item providers.FeedItem) {
	imageURL := item.ImageURL()
	if imageURL == "" {
		return
	}

	atom.WriteString(fmt.Sprintf(`<media:thumbnail url="%s"/>`, EscapeXML(imageURL)))
}
