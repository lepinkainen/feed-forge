package feed

import (
	"fmt"
	"html/template"
	"io"
	"log/slog"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/lepinkainen/feed-forge/pkg/opengraph"
	"github.com/lepinkainen/feed-forge/pkg/providers"
)

// TemplateGenerator handles template-based feed generation
type TemplateGenerator struct {
	templates map[string]*template.Template
	funcMap   template.FuncMap
}

// FeedTemplateData represents the data structure passed to feed templates
type FeedTemplateData struct {
	// Feed metadata
	FeedTitle       string
	FeedLink        string
	FeedDescription string
	FeedAuthor      string
	FeedID          string
	Updated         string
	Generator       string

	// Items
	Items []TemplateItem

	// OpenGraph data map (URL -> OpenGraph data)
	OpenGraphData map[string]*opengraph.Data
}

// TemplateItem represents a feed item for template rendering
type TemplateItem struct {
	Title        string
	Link         string
	CommentsLink string
	ID           string
	Updated      string
	Published    string
	Author       string
	AuthorURI    string
	Categories   []string
	Score        int
	Comments     int
	Content      string
	Summary      string
	ImageURL     string
	Subreddit    string // Reddit-specific
	Domain       string // HN-specific
}

// NewTemplateGenerator creates a new template-based feed generator
func NewTemplateGenerator() *TemplateGenerator {
	return &TemplateGenerator{
		templates: make(map[string]*template.Template),
		funcMap:   TemplateFuncs(),
	}
}

// LoadTemplate loads a template from file with the given name
func (tg *TemplateGenerator) LoadTemplate(name, filePath string) error {
	slog.Debug("Loading template", "name", name, "path", filePath)

	// Read template content
	content, err := os.ReadFile(filePath)
	if err != nil {
		return fmt.Errorf("failed to read template file %s: %w", filePath, err)
	}

	// Parse template with the specified name
	tmpl, err := template.New(name).Funcs(tg.funcMap).Parse(string(content))
	if err != nil {
		return fmt.Errorf("failed to parse template %s: %w", filePath, err)
	}

	tg.templates[name] = tmpl
	slog.Debug("Template loaded successfully", "name", name)
	return nil
}

// LoadTemplatesFromDir loads all templates from a directory
func (tg *TemplateGenerator) LoadTemplatesFromDir(dir string) error {
	slog.Debug("Loading templates from directory", "dir", dir)

	return filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		if info.IsDir() || !strings.HasSuffix(path, ".tmpl") {
			return nil
		}

		// Use filename without extension as template name
		name := strings.TrimSuffix(info.Name(), ".tmpl")
		return tg.LoadTemplate(name, path)
	})
}

// GenerateFromTemplate generates a feed using the specified template
func (tg *TemplateGenerator) GenerateFromTemplate(templateName string, data *FeedTemplateData, writer io.Writer) error {
	tmpl, exists := tg.templates[templateName]
	if !exists {
		return fmt.Errorf("template %s not found", templateName)
	}

	slog.Debug("Executing template", "name", templateName, "items", len(data.Items))

	err := tmpl.Execute(writer, data)
	if err != nil {
		return fmt.Errorf("failed to execute template %s: %w", templateName, err)
	}

	slog.Debug("Template executed successfully", "name", templateName)
	return nil
}

// CreateRedditFeedData converts Reddit posts to template data
func (tg *TemplateGenerator) CreateRedditFeedData(posts []providers.FeedItem, ogData map[string]*opengraph.Data) *FeedTemplateData {
	now := time.Now()

	data := &FeedTemplateData{
		FeedTitle:       "Reddit Homepage",
		FeedLink:        "https://www.reddit.com/",
		FeedDescription: "Filtered Reddit homepage posts generated by Feed Forge",
		FeedAuthor:      "Feed Forge",
		FeedID:          "https://www.reddit.com/",
		Updated:         now.Format(time.RFC3339),
		Generator:       "Feed Forge",
		OpenGraphData:   ogData,
		Items:           make([]TemplateItem, len(posts)),
	}

	for i, post := range posts {
		data.Items[i] = TemplateItem{
			Title:        post.Title(),
			Link:         post.Link(),
			CommentsLink: post.CommentsLink(),
			ID:           post.CommentsLink(),
			Updated:      post.CreatedAt().Format(time.RFC3339),
			Published:    post.CreatedAt().Format(time.RFC3339),
			Author:       post.Author(),
			AuthorURI:    fmt.Sprintf("https://www.reddit.com/user/%s", post.Author()),
			Categories:   post.Categories(),
			Score:        post.Score(),
			Comments:     post.CommentCount(),
			Summary:      fmt.Sprintf("Score: %d | Comments: %d", post.Score(), post.CommentCount()),
		}

		// Extract subreddit for Reddit posts
		if len(post.Categories()) > 0 && strings.HasPrefix(post.Categories()[0], "r/") {
			data.Items[i].Subreddit = strings.TrimPrefix(post.Categories()[0], "r/")
		}
	}

	return data
}

// CreateHackerNewsFeedData converts Hacker News stories to template data
func (tg *TemplateGenerator) CreateHackerNewsFeedData(items []providers.FeedItem, ogData map[string]*opengraph.Data) *FeedTemplateData {
	now := time.Now()

	data := &FeedTemplateData{
		FeedTitle:       "Hacker News Top Stories",
		FeedLink:        "https://news.ycombinator.com/",
		FeedDescription: "High-quality Hacker News stories, updated regularly",
		FeedAuthor:      "Feed Forge",
		FeedID:          "https://news.ycombinator.com/",
		Updated:         now.Format(time.RFC3339),
		Generator:       "Feed Forge",
		OpenGraphData:   ogData,
		Items:           make([]TemplateItem, len(items)),
	}

	for i, item := range items {
		data.Items[i] = TemplateItem{
			Title:        item.Title(),
			Link:         item.Link(),
			CommentsLink: item.CommentsLink(),
			ID:           item.CommentsLink(),
			Updated:      item.CreatedAt().Format(time.RFC3339),
			Published:    item.CreatedAt().Format(time.RFC3339),
			Author:       item.Author(),
			AuthorURI:    fmt.Sprintf("https://news.ycombinator.com/user?id=%s", item.Author()),
			Categories:   item.Categories(),
			Score:        item.Score(),
			Comments:     item.CommentCount(),
			Summary:      fmt.Sprintf("Score: %d | Comments: %d", item.Score(), item.CommentCount()),
		}

		// Extract domain for Hacker News posts
		if len(item.Categories()) > 0 {
			for _, category := range item.Categories() {
				// Look for domain-like categories (contain dots)
				if strings.Contains(category, ".") && !strings.Contains(category, " ") {
					data.Items[i].Domain = category
					break
				}
			}
		}
	}

	return data
}

// BuildEnhancedContent creates enhanced HTML content for template items
func (tg *TemplateGenerator) BuildEnhancedContent(item TemplateItem, ogData map[string]*opengraph.Data) string {
	var content strings.Builder

	// Add basic metadata
	content.WriteString(fmt.Sprintf(`<div class="metadata">
<p><strong>Score:</strong> %d | <strong>Comments:</strong> %d</p>
</div>`, item.Score, item.Comments))

	// Add OpenGraph preview if available
	if ogData != nil && item.Link != "" {
		if og, exists := ogData[item.Link]; exists && og != nil {
			content.WriteString(`<div class="link-preview">`)
			content.WriteString(`<h3>ðŸ”— Link Preview</h3>`)

			if og.Image != "" {
				content.WriteString(fmt.Sprintf(`<img src="%s" alt="Preview image" style="max-width: 200px; height: auto;"/>`, og.Image))
			}

			if og.Title != "" {
				content.WriteString(fmt.Sprintf(`<h4>%s</h4>`, og.Title))
			}

			if og.Description != "" {
				content.WriteString(fmt.Sprintf(`<p>%s</p>`, og.Description))
			}

			if og.SiteName != "" {
				content.WriteString(fmt.Sprintf(`<p><em>Source: %s</em></p>`, og.SiteName))
			}

			content.WriteString(`</div>`)
		}
	}

	// Add links section
	content.WriteString(`<div class="links">`)
	if item.Link != "" && item.Link != item.CommentsLink {
		content.WriteString(fmt.Sprintf(`<p><a href="%s">View External Link</a> | <a href="%s">View Comments</a></p>`, item.Link, item.CommentsLink))
	} else {
		content.WriteString(fmt.Sprintf(`<p><a href="%s">View Link</a></p>`, item.CommentsLink))
	}
	content.WriteString(`</div>`)

	return content.String()
}

// GetAvailableTemplates returns a list of loaded template names
func (tg *TemplateGenerator) GetAvailableTemplates() []string {
	templates := make([]string, 0, len(tg.templates))
	for name := range tg.templates {
		templates = append(templates, name)
	}
	return templates
}
