package redditjson

import (
	"fmt"
	"log/slog"

	"github.com/lepinkainen/feed-forge/pkg/feed"
	"github.com/lepinkainen/feed-forge/pkg/filesystem"
	"github.com/lepinkainen/feed-forge/pkg/providers"
)

// constructFeedURL builds the Reddit JSON feed URL from feed ID and username
func constructFeedURL(feedID, username string) string {
	return fmt.Sprintf("https://www.reddit.com/.json?feed=%s&user=%s", feedID, username)
}

// RedditProvider implements the FeedProvider interface for Reddit JSON feeds
type RedditProvider struct {
	*providers.BaseProvider
	MinScore    int
	MinComments int
	FeedID      string
	Username    string
}

// Config holds Reddit provider configuration for the factory
type Config struct {
	MinScore    int
	MinComments int
	FeedID      string
	Username    string
}

// NewRedditProvider creates a new Reddit JSON provider
func NewRedditProvider(minScore, minComments int, feedID, username string) providers.FeedProvider {
	base, err := providers.NewBaseProvider(providers.DatabaseConfig{
		ContentDBName: "", // Reddit JSON doesn't use content DB
		UseContentDB:  false,
	})
	if err != nil {
		// TODO: Handle error properly - for now return nil
		return nil
	}

	return &RedditProvider{
		BaseProvider: base,
		MinScore:     minScore,
		MinComments:  minComments,
		FeedID:       feedID,
		Username:     username,
	}
}

// factory creates a Reddit provider from configuration
func factory(config any) (providers.FeedProvider, error) {
	cfg, ok := config.(*Config)
	if !ok {
		return nil, fmt.Errorf("invalid config type for reddit provider: expected *redditjson.Config")
	}

	provider := NewRedditProvider(cfg.MinScore, cfg.MinComments, cfg.FeedID, cfg.Username)
	if provider == nil {
		return nil, fmt.Errorf("failed to create reddit provider")
	}

	return provider, nil
}

func init() {
	providers.MustRegister("reddit", &providers.ProviderInfo{
		Name:        "reddit",
		Description: "Generate RSS feeds from Reddit JSON feeds",
		Version:     "1.0.0",
		Factory:     factory,
	})
}

// FetchItems implements the FeedProvider interface
func (p *RedditProvider) FetchItems(limit int) ([]providers.FeedItem, error) {
	// Construct feed URL from config parameters
	feedURL := constructFeedURL(p.FeedID, p.Username)

	// Create Reddit API client with constructed URL
	redditAPI := NewRedditAPI(feedURL)

	// Fetch Reddit posts from JSON feed
	posts, err := redditAPI.FetchRedditHomepage()
	if err != nil {
		return nil, err
	}

	// Filter posts
	filteredPosts := FilterPosts(posts, p.MinScore, p.MinComments)

	// Apply limit if specified
	if limit > 0 && limit < len(filteredPosts) {
		filteredPosts = filteredPosts[:limit]
	}

	// Convert to FeedItem interface
	feedItems := make([]providers.FeedItem, len(filteredPosts))
	for i, post := range filteredPosts {
		feedItems[i] = &post
	}

	return feedItems, nil
}

// GenerateFeed implements the FeedProvider interface
func (p *RedditProvider) GenerateFeed(outfile string, _ bool) error {
	// reauth parameter is ignored for JSON feeds (no authentication needed)

	// Clean up expired entries using base provider
	if err := p.CleanupExpired(); err != nil {
		slog.Warn("Failed to cleanup expired entries", "error", err)
	}

	// Fetch items using the shared FetchItems method
	feedItems, err := p.FetchItems(0) // 0 means no limit
	if err != nil {
		return err
	}

	// Ensure output directory exists
	if err := filesystem.EnsureDirectoryExists(outfile); err != nil {
		return err
	}

	// Define feed configuration
	feedConfig := feed.Config{
		Title:       "Reddit Homepage",
		Link:        "https://www.reddit.com/",
		Description: "Filtered Reddit homepage posts generated by Feed Forge",
		Author:      "Feed Forge",
		ID:          "https://www.reddit.com/",
	}

	// Generate Atom feed using embedded templates with local override
	if err := feed.SaveAtomFeedToFileWithEmbeddedTemplate(feedItems, "reddit-atom", outfile, feedConfig, p.OgDB); err != nil {
		return err
	}

	feed.LogFeedGeneration(len(feedItems), outfile)
	return nil
}
