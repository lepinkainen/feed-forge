package redditjson

import (
	"fmt"
	"html"
	"log/slog"
	"os"
	"strings"
	"time"

	"github.com/gorilla/feeds"
	feedpkg "github.com/lepinkainen/feed-forge/pkg/feed"
	"github.com/lepinkainen/feed-forge/pkg/opengraph"
	"github.com/lepinkainen/feed-forge/pkg/providers"
)

// FeedGenerator wraps the shared feed generator with Reddit-specific functionality
type FeedGenerator struct {
	generator *feedpkg.Generator
	ogFetcher *opengraph.Fetcher
}

// NewFeedGenerator creates a new feed generator with OpenGraph fetcher
func NewFeedGenerator(ogFetcher *opengraph.Fetcher) *FeedGenerator {
	generator := feedpkg.NewGenerator(
		"Reddit Homepage",
		"Filtered Reddit homepage posts generated by Feed Forge",
		"https://www.reddit.com/",
		"Feed Forge",
	)

	return &FeedGenerator{
		generator: generator,
		ogFetcher: ogFetcher,
	}
}

// GenerateFeed creates an RSS or Atom feed from the filtered Reddit posts
func (fg *FeedGenerator) GenerateFeed(posts []RedditPost, feedType string) (*feeds.Feed, error) {
	// Convert feedType string to FeedType
	var ft feedpkg.FeedType
	switch feedType {
	case "rss":
		ft = feedpkg.RSS
	case "atom":
		ft = feedpkg.Atom
	default:
		return nil, fmt.Errorf("unsupported feed type: %s", feedType)
	}

	// Convert Reddit posts to FeedItem interface
	items := make([]providers.FeedItem, len(posts))
	for i, post := range posts {
		items[i] = &post
	}

	// Use shared generator with OpenGraph support
	feed, _, err := fg.generator.GenerateWithOpenGraph(items, ft, fg.ogFetcher)
	if err != nil {
		return nil, fmt.Errorf("failed to generate feed: %w", err)
	}

	slog.Debug("Generated feed using shared infrastructure", "type", feedType, "items", len(feed.Items))
	return feed, nil
}

// SaveFeedToFile saves the generated feed to a specified file
func (fg *FeedGenerator) SaveFeedToFile(feed *feeds.Feed, feedType, outputPath string) error {
	// Convert feedType string to FeedType
	var ft feedpkg.FeedType
	switch feedType {
	case "rss":
		ft = feedpkg.RSS
	case "atom":
		ft = feedpkg.Atom
	default:
		return fmt.Errorf("unsupported feed type: %s", feedType)
	}

	// Use shared save functionality
	return fg.generator.SaveToFile(feed, ft, outputPath)
}

// SaveCustomAtomFeedToFile saves a custom enhanced Atom feed using our custom content generation
func (fg *FeedGenerator) SaveCustomAtomFeedToFile(posts []RedditPost, outputPath string) error {
	// Use our custom Atom feed generation that includes selftext_html content
	atomContent, err := fg.CreateCustomAtomFeed(posts)
	if err != nil {
		return fmt.Errorf("failed to generate custom atom feed: %w", err)
	}

	file, err := os.Create(outputPath)
	if err != nil {
		return fmt.Errorf("failed to create output file: %w", err)
	}
	defer file.Close()

	_, err = file.WriteString(atomContent)
	if err != nil {
		return fmt.Errorf("failed to write custom atom feed: %w", err)
	}

	slog.Info("Custom Atom feed saved successfully", "path", outputPath)
	return nil
}

// ValidateFeed validates the generated feed structure
func (fg *FeedGenerator) ValidateFeed(feed *feeds.Feed) error {
	return fg.generator.ValidateFeed(feed)
}

// GetFeedMetadata returns metadata about the generated feed
func (fg *FeedGenerator) GetFeedMetadata(feed *feeds.Feed) *feedpkg.Metadata {
	return fg.generator.GetMetadata(feed)
}

// CreateCustomAtomFeed creates a custom Atom feed structure with enhanced features
func (fg *FeedGenerator) CreateCustomAtomFeed(posts []RedditPost) (string, error) {
	now := time.Now()

	// Collect URLs for concurrent OpenGraph fetching
	urls := make([]string, 0, len(posts))
	for _, post := range posts {
		if post.Data.URL != "" {
			urls = append(urls, post.Data.URL)
		}
	}

	// Fetch OpenGraph data concurrently
	var ogData map[string]*opengraph.Data
	if fg.ogFetcher != nil {
		slog.Debug("Fetching OpenGraph data for custom Atom feed", "url_count", len(urls))
		ogData = fg.ogFetcher.FetchConcurrent(urls)
	}

	var atom strings.Builder
	atom.WriteString(`<?xml version="1.0" encoding="UTF-8"?>`)
	atom.WriteString(`<feed xmlns="http://www.w3.org/2005/Atom" xmlns:reddit="http://reddit.com/atom/ns">`)
	atom.WriteString(`<title>Reddit Homepage</title>`)
	atom.WriteString(`<link href="https://www.reddit.com/"/>`)
	atom.WriteString(`<id>https://www.reddit.com/</id>`)
	atom.WriteString(fmt.Sprintf(`<updated>%s</updated>`, now.Format(time.RFC3339)))
	atom.WriteString(`<author><name>Feed Forge</name></author>`)
	atom.WriteString(`<subtitle>Filtered Reddit homepage posts with enhanced metadata</subtitle>`)
	atom.WriteString(`<generator uri="https://github.com/lepinkainen/feed-forge">Red RSS Generator</generator>`)

	for _, post := range posts {
		atom.WriteString(`<entry>`)
		atom.WriteString(fmt.Sprintf(`<title>%s</title>`, feedpkg.EscapeXML(post.Data.Title)))

		// Multiple links: Reddit permalink and external URL
		atom.WriteString(fmt.Sprintf(`<link rel="alternate" type="text/html" href="%s"/>`, feedpkg.EscapeXML(post.Data.URL)))
		atom.WriteString(fmt.Sprintf(`<link rel="replies" type="text/html" href="https://www.reddit.com%s" title="Reddit Discussion"/>`, feedpkg.EscapeXML(post.Data.Permalink)))

		atom.WriteString(fmt.Sprintf(`<id>https://www.reddit.com%s</id>`, feedpkg.EscapeXML(post.Data.Permalink)))
		atom.WriteString(fmt.Sprintf(`<updated>%s</updated>`, time.Unix(int64(post.Data.CreatedUTC), 0).Format(time.RFC3339)))
		atom.WriteString(fmt.Sprintf(`<published>%s</published>`, time.Unix(int64(post.Data.CreatedUTC), 0).Format(time.RFC3339)))

		// Enhanced author information
		atom.WriteString(fmt.Sprintf(`<author><name>%s</name><uri>https://www.reddit.com/user/%s</uri></author>`, feedpkg.EscapeXML(post.Data.Author), feedpkg.EscapeXML(post.Data.Author)))

		// Categories for subreddit
		atom.WriteString(fmt.Sprintf(`<category term="r/%s" label="r/%s"/>`, feedpkg.EscapeXML(post.Data.Subreddit), feedpkg.EscapeXML(post.Data.Subreddit)))

		// Reddit-specific metadata using custom namespace
		atom.WriteString(fmt.Sprintf(`<reddit:score>%d</reddit:score>`, post.Data.Score))
		atom.WriteString(fmt.Sprintf(`<reddit:comments>%d</reddit:comments>`, post.Data.NumComments))
		atom.WriteString(fmt.Sprintf(`<reddit:subreddit>r/%s</reddit:subreddit>`, feedpkg.EscapeXML(post.Data.Subreddit)))

		// Enhanced content with OpenGraph data
		content := fg.buildEnhancedContent(post, ogData)
		atom.WriteString(fmt.Sprintf(`<content type="html"><![CDATA[%s]]></content>`, content))

		// Summary
		summary := fmt.Sprintf("Score: %d, Comments: %d",
			post.Data.Score, post.Data.NumComments)
		atom.WriteString(fmt.Sprintf(`<summary>%s</summary>`, feedpkg.EscapeXML(summary)))

		// Add thumbnail as enclosure if available from OpenGraph
		if ogData != nil {
			if og, exists := ogData[post.Data.URL]; exists && og != nil && og.Image != "" {
				atom.WriteString(fmt.Sprintf(`<link rel="enclosure" type="image/jpeg" href="%s"/>`, feedpkg.EscapeXML(og.Image)))
			}
		}

		atom.WriteString(`</entry>`)
	}

	atom.WriteString(`</feed>`)
	return atom.String(), nil
}

// buildEnhancedContent creates rich HTML content for Atom feeds
func (fg *FeedGenerator) buildEnhancedContent(post RedditPost, ogData map[string]*opengraph.Data) string {
	var content strings.Builder

	// Add selftext HTML content if available (prioritize this over OpenGraph)
	if post.Data.SelfTextHTML != "" && post.Data.SelfTextHTML != "null" {
		cleanHTML := fg.cleanRedditHTML(post.Data.SelfTextHTML)
		content.WriteString(cleanHTML)
		content.WriteString(`<br/><br/>`)
	}

	// Add submission metadata in Reddit RSS format
	content.WriteString(fmt.Sprintf(`submitted by <a href="https://www.reddit.com/user/%s">/u/%s</a> to <a href="https://www.reddit.com/r/%s/">r/%s</a>`,
		post.Data.Author, post.Data.Author, post.Data.Subreddit, post.Data.Subreddit))
	content.WriteString(`<br/>`)

	// Add links in Reddit RSS format
	if post.Data.URL != "" && post.Data.URL != "https://www.reddit.com"+post.Data.Permalink {
		// External link exists and is different from permalink
		content.WriteString(fmt.Sprintf(` <span><a href="%s">[link]</a></span> <span><a href="https://www.reddit.com%s">[comments]</a></span>`,
			post.Data.URL, post.Data.Permalink))
	} else {
		// Self-post or permalink only
		content.WriteString(fmt.Sprintf(` <span><a href="https://www.reddit.com%s">[link]</a></span> <span><a href="https://www.reddit.com%s">[comments]</a></span>`,
			post.Data.Permalink, post.Data.Permalink))
	}

	return content.String()
}

// cleanRedditHTML removes Reddit-specific HTML comments and decodes HTML entities
func (fg *FeedGenerator) cleanRedditHTML(htmlContent string) string {
	// First, decode HTML entities (Reddit sends HTML-encoded content)
	htmlContent = html.UnescapeString(htmlContent)

	// Remove Reddit-specific HTML comments
	htmlContent = strings.ReplaceAll(htmlContent, "<!-- SC_OFF -->", "")
	htmlContent = strings.ReplaceAll(htmlContent, "<!-- SC_ON -->", "")

	// Remove any extra whitespace that might result from comment removal
	htmlContent = strings.TrimSpace(htmlContent)

	return htmlContent
}
