package redditjson

import (
	"fmt"
	"log/slog"
	"os"
	"strings"

	"github.com/gorilla/feeds"
	feedpkg "github.com/lepinkainen/feed-forge/pkg/feed"
	"github.com/lepinkainen/feed-forge/pkg/opengraph"
	"github.com/lepinkainen/feed-forge/pkg/providers"
)

// FeedGenerator wraps the shared feed generator with Reddit-specific functionality
type FeedGenerator struct {
	generator *feedpkg.Generator
	ogFetcher *opengraph.Fetcher
}

// NewFeedGenerator creates a new feed generator with OpenGraph fetcher
func NewFeedGenerator(ogFetcher *opengraph.Fetcher) *FeedGenerator {
	generator := feedpkg.NewGenerator(
		"Reddit Homepage",
		"Filtered Reddit homepage posts generated by Feed Forge",
		"https://www.reddit.com/",
		"Feed Forge",
	)

	return &FeedGenerator{
		generator: generator,
		ogFetcher: ogFetcher,
	}
}

// GenerateFeed creates an RSS or Atom feed from the filtered Reddit posts
func (fg *FeedGenerator) GenerateFeed(posts []RedditPost, feedType string) (*feeds.Feed, error) {
	// Convert feedType string to FeedType
	var ft feedpkg.FeedType
	switch feedType {
	case "rss":
		ft = feedpkg.RSS
	case "atom":
		ft = feedpkg.Atom
	default:
		return nil, fmt.Errorf("unsupported feed type: %s", feedType)
	}

	// Convert Reddit posts to FeedItem interface
	items := make([]providers.FeedItem, len(posts))
	for i, post := range posts {
		items[i] = &post
	}

	// Use shared generator with OpenGraph support
	feed, _, err := fg.generator.GenerateWithOpenGraph(items, ft, fg.ogFetcher)
	if err != nil {
		return nil, fmt.Errorf("failed to generate feed: %w", err)
	}

	slog.Debug("Generated feed using shared infrastructure", "type", feedType, "items", len(feed.Items))
	return feed, nil
}

// SaveFeedToFile saves the generated feed to a specified file
func (fg *FeedGenerator) SaveFeedToFile(feed *feeds.Feed, feedType, outputPath string) error {
	// Convert feedType string to FeedType
	var ft feedpkg.FeedType
	switch feedType {
	case "rss":
		ft = feedpkg.RSS
	case "atom":
		ft = feedpkg.Atom
	default:
		return fmt.Errorf("unsupported feed type: %s", feedType)
	}

	// Use shared save functionality
	return fg.generator.SaveToFile(feed, ft, outputPath)
}

// ValidateFeed validates the generated feed structure
func (fg *FeedGenerator) ValidateFeed(feed *feeds.Feed) error {
	return fg.generator.ValidateFeed(feed)
}

// GetFeedMetadata returns metadata about the generated feed
func (fg *FeedGenerator) GetFeedMetadata(feed *feeds.Feed) *feedpkg.Metadata {
	return fg.generator.GetMetadata(feed)
}

// buildEnhancedContent creates rich HTML content for Atom feeds
func (fg *FeedGenerator) buildEnhancedContent(post RedditPost, ogData map[string]*opengraph.Data) string {
	var content strings.Builder

	// Add image if available
	if imageURL := post.ImageURL(); imageURL != "" {
		content.WriteString(fmt.Sprintf(`<div><img src="%s" alt="%s" style="max-width: 100%%; height: auto;"/></div><br/>`,
			imageURL, post.Data.Title))
	}

	// Add selftext HTML content if available (prioritize this over OpenGraph)
	if post.Data.SelfTextHTML != "" && post.Data.SelfTextHTML != "null" {
		cleanHTML := cleanRedditHTML(post.Data.SelfTextHTML)
		content.WriteString(cleanHTML)
		content.WriteString(`<br/><br/>`)
	}

	// Add submission metadata in Reddit RSS format
	content.WriteString(fmt.Sprintf(`submitted by <a href="https://www.reddit.com/user/%s">/u/%s</a> to <a href="https://www.reddit.com/r/%s/">r/%s</a>`,
		post.Data.Author, post.Data.Author, post.Data.Subreddit, post.Data.Subreddit))
	content.WriteString(`<br/>`)

	// Add links in Reddit RSS format
	if post.Data.URL != "" && post.Data.URL != "https://www.reddit.com"+post.Data.Permalink {
		// External link exists and is different from permalink
		content.WriteString(fmt.Sprintf(` <span><a href="%s">[link]</a></span> <span><a href="https://www.reddit.com%s">[comments]</a></span>`,
			post.Data.URL, post.Data.Permalink))
	} else {
		// Self-post or permalink only
		content.WriteString(fmt.Sprintf(` <span><a href="https://www.reddit.com%s">[link]</a></span> <span><a href="https://www.reddit.com%s">[comments]</a></span>`,
			post.Data.Permalink, post.Data.Permalink))
	}

	return content.String()
}

// generateRedditRSSFeed creates an Atom RSS feed from the provided items with OpenGraph data
func generateRedditRSSFeed(posts []RedditPost, ogFetcher *opengraph.Fetcher) (string, error) {
	slog.Debug("Generating RSS feed using enhanced Atom infrastructure", "itemCount", len(posts))

	// Create shared feed generator
	generator := feedpkg.NewGenerator(
		"Reddit Homepage",
		"Filtered Reddit homepage posts with enhanced metadata",
		"https://www.reddit.com/",
		"Feed Forge",
	)

	// Convert to FeedItem interface
	feedItems := make([]providers.FeedItem, len(posts))
	for i, post := range posts {
		feedItems[i] = &post
	}

	// Use enhanced Atom generation with Reddit-specific configuration
	config := feedpkg.RedditEnhancedAtomConfig()
	atomContent, err := generator.GenerateEnhancedAtomWithConfig(feedItems, config, ogFetcher)
	if err != nil {
		slog.Error("Failed to generate enhanced Atom feed", "error", err)
		return "", err
	}

	slog.Debug("Enhanced Atom feed generated successfully", "feedSize", len(atomContent))
	return atomContent, nil
}

// generateRedditTemplateFeed creates an Atom RSS feed using template-based generation
func generateRedditTemplateFeed(posts []RedditPost, ogFetcher *opengraph.Fetcher) (string, error) {
	slog.Debug("Generating RSS feed using template-based generation", "itemCount", len(posts))

	// Create template generator
	templateGenerator := feedpkg.NewTemplateGenerator()

	// Load Reddit template
	err := templateGenerator.LoadTemplate("reddit-atom", "templates/reddit-atom.tmpl")
	if err != nil {
		slog.Warn("Failed to load Reddit Atom template, falling back to enhanced generation", "error", err)
		return generateRedditRSSFeed(posts, ogFetcher)
	}

	// Convert to FeedItem interface
	feedItems := make([]providers.FeedItem, len(posts))
	for i, post := range posts {
		feedItems[i] = &post
	}

	// Collect URLs for OpenGraph fetching
	urls := make([]string, 0, len(feedItems))
	for _, item := range feedItems {
		if item.Link() != "" && item.Link() != item.CommentsLink() {
			urls = append(urls, item.Link())
		}
	}

	// Fetch OpenGraph data concurrently
	var ogData map[string]*opengraph.Data
	if ogFetcher != nil {
		slog.Debug("Fetching OpenGraph data for template feed", "url_count", len(urls))
		ogData = ogFetcher.FetchConcurrent(urls)
	}

	// Create template data
	templateData := templateGenerator.CreateRedditFeedData(feedItems, ogData)

	// Generate using template
	var atomContent strings.Builder
	err = templateGenerator.GenerateFromTemplate("reddit-atom", templateData, &atomContent)
	if err != nil {
		slog.Error("Failed to generate template feed", "error", err)
		return "", err
	}

	slog.Debug("Template-based Atom feed generated successfully", "feedSize", len(atomContent.String()))
	return atomContent.String(), nil
}

// SaveRedditFeedToFile saves a Reddit Atom feed using the enhanced generation system
func SaveRedditFeedToFile(posts []RedditPost, outputPath string, ogFetcher *opengraph.Fetcher, useTemplate bool) error {
	slog.Debug("Generating Reddit Atom feed", "outputPath", outputPath, "postCount", len(posts), "useTemplate", useTemplate)

	var atomContent string
	var err error

	if useTemplate {
		atomContent, err = generateRedditTemplateFeed(posts, ogFetcher)
	} else {
		atomContent, err = generateRedditRSSFeed(posts, ogFetcher)
	}

	if err != nil {
		slog.Error("Failed to generate Atom feed", "error", err)
		return err
	}

	return os.WriteFile(outputPath, []byte(atomContent), 0644)
}
